_**Общие требования**_. Данное техническое задание формулирует следующие требования к вашему ПО:
1. Модуль, реализующий стек, должен быть выполнен как _статическая библиотека_. Это требование выполняется автоматически
([CMakeLists.txt](https://github.com/czertyaka/prosoft-c-stack/blob/master/CMakeLists.txt)) - весь код из `cstack.c` попадет в библиотеку.
2. Библиотека должна _собираться_, т.е. в ней не должно быть ошибок компиляции и линковки (за исключением ситуации отсутствия на машине
сборки стандартной библиотеки C).
3. Библиотека _не должна иметь зависимостей_ иных, чем стандартная библиотека C. Не сомневаюсь, что при должном упорстве можно найти готовые реализации стека на С, удовлетворяющие нашим требования. Это не наш случай :smiling_face_with_tear:.
4. Функции библиотеки должны удовлетворять требованиям, описанным ниже.
5. Библиотека должна корректно _освобождать ресурсы памяти_ при должном использовании.
6. Библиотека должна быть _отказоустойчива_ (в разумных пределах) _к входным данным_ функций, т.е. должны быть введены разумные проверки на нулевой указатель, нулевой размер и т.д. Понятно, что проверить валидность переданного указателя (например, что он не указывает в начало адресного пространства) невозможно или очень трудно, но полноценная проверка и не является ответственностью библиотеки.
7. В ходе нормального выполнения и использования кода библиотеки не должны возникать ошибки сегментации, переполнения стека, обращения к
памяти и др.
8. Библиотека не гарантирует: освобождение ресурсов памяти при некорректном использовании функций библиотеки; отсутствие недекларированного
поведения в случае передачи невалидного указателя (за исключением нулевого указателя).

Валидация этих требований будет осуществляется в процессе код-ревью, сборки и юнит-тестирования. Обратите внимание, что последние два
валидатора могут быть выполнены вами в целях экономии времени (в том числе и вашего). Но это лишь предложение по оптимизации процесса
проверки, а не требование. Обратите внимание, что юнит-тесты могут быть модифицированы в случае выявления недостаточности проверок/несоответствия приведенным выше требованиям. Требования - первичны, а тесты всего лишь их выражают.

_**Особенности нашей реализации стека**_.
1. Библиотека может одновременно обслуживать несколько стеков.
2. Данные, хранимые в стеке, не типизированны.

**_Требования к функциям библиотеки_**.
Одним из аргументов большинства функций библиотеки является _хэндлер_ стека с типом `t_hstack`. Этот тип является псевдонимом типа `int`
и к реализации стека в памяти отношения не имеет. Скорее это абстрактный идентификатор, который нужен, чтобы отличить один стек от другого.
Отмечу, что в C использование _хэндлера_, (_дескриптора_), является стандартной практикой. Примеры:
[hInstance](https://learn.microsoft.com/ru-ru/windows/win32/learnwin32/winmain--the-application-entry-point) в `WinAPI`, возвращаемое
значение функции [open](https://man7.org/linux/man-pages/man2/open.2.html) в `POSIX`. Объявление этого типа находится в заголовочном файле
[cstack.h](https://github.com/czertyaka/prosoft-c-stack/blob/master/cstack.h).

* `hstack_t stack_new()`  
**Brief**: Создать новый стек.  
**Returns**: `-1` в случае ошибки выполнения, хэндлер нового стека с неотрицательным значением в случае успеха.

* `void stack_free(const hstack_t stack)`  
**Brief**: Удалить стек.  
**Parameters**: `stack` - хэндлер стека.

* `int stack_valid_handler(const hstack_t stack)`  
**Brief**: Проверить хэндлер.  
**Parameters**: `stack` - хэндлер стека.  
**Returns**: 0 - соответствующий хэндлеру стек существует, 1 - нет.

* `unsigned int stack_size(const hstack_t stack)`  
**Brief**: Получить количество элементов в стеке.  
**Parameters**: `stack` - хэндлер стека.  
**Returns**: количество элементов в стеке.

* `void stack_push(const hstack_t stack, const void* data_in, const unsigned int size)`  
**Brief**: Добавить элемент данных из буфера в стек.  
**Parameters**: `stack` - хэндлер стека; `data_in` - указатель на буфер с данными; `size` - размер буфера с данными.

* `unsigned int stack_pop(const hstack_t stack, void* data_out, const unsigned int size)`  
**Brief**: Извлесь элемент из стека и записать данные этого элемента в буфер.  
**Parameters**: `stack` - хэндлер стека; `data_out` - указатель на буфер для записи данных; `size` - размер буфера.  
**Returns**: размер записанных данных в байтах.

**_Подсказки по реализации_**. Прежде чем давать задание вам, я самостоятельно реализовал стек, чтобы было проще декомпозировать задачу и
подумать, в каких местах стоит дать подсказки. Эта часть необязательна к прочтению, ограничений на реализацию я не ставлю (кроме приведенных
в требованиях).

На мой взгляд, две главные проблемы, которые вам предстоит решить - как хранить сами данные в стеке и как устанавливать соответствие между
хэндлером и стеком.

Первая проблема решалась бы тривиально, если бы ме релизовывали стек, хранящий типизированные данные. Тогда мы бы на этапе компиляции знали размер одного элемента стека. Например, если бы мы хранили `int`, размер элемента стека в простой реализации был бы равен `sizeof(int)`. В этом случае можно было бы вовсе обойтись без динамической памяти. Пример можно найти [тут](http://shujkova.ru/sites/default/files/lec1.pdf).
Для случая неизвестного на этапе компиляции размера я выбрал вот такое решение:
```c
struct node
{
    const struct node* prev;
    unsigned int size;
    char data[0];
};
```
Такой подход напоминает другую структуру данных [односвязный список](https://prog-cpp.ru/data-ols/). Из общего у них наличие указателя
на предыдущий элемент. При добавлении нового элемента в стек удобно в рантайме посчитать количество данных элемента стека (размер указателя на предыдущий элемент `prev` + размер поля `size` + размер самих данных), аллоцировать эти данные и заполнить их. Это не единственно верный
вариант, возможны альтернативы.

Вторую проблему я решил следующим образом: завел глобальный динамический массив указателей на верхушки стека так, чтобы дескриптор стека
являлся одновременно и индексом в этом массиве. Добавил несколько оптимизаций, но общая идея такая.
```c
struct stack_entry
{
    int reserved;
    stack_t stack;
};

typedef struct stack_entry stack_entry_t;

struct stack_entries_table
{
    unsigned int size;
    stack_entry_t* entries;
};

struct stack_entries_table g_table = {0u, NULL};
```
**_Пошаговая инструкция_**

1. Заведите профиль на <https://github.com/> и отправьте ссылку на него Ирине Холодной. После этого я сделаю
[репозиторий с домашним заданием](https://github.com/czertyaka/prosoft-c-stack/) видимым для вас.
2. Осмотритесь в репозитории. Загляните в файлы с исходным кодом, ознакомьтесь с [README.md](https://github.com/czertyaka/prosoft-c-stack/blob/master/README.md). На изображении ниже показано, как найти данное сопровождение.  
![image](https://user-images.githubusercontent.com/69390349/202924893-563ba57f-1fd3-4923-b22c-e8800312b7c9.png)
3. Сделайте форк репозитория. У вас кнопка должны быть активна и кликабельна (я же не могу выполнить форк своего репозитория).
После этого в вашем аккаунте среди ваших репозиториев появится копия данного репозитория с веткой `master`.  
![image](https://user-images.githubusercontent.com/69390349/202925011-19d01f09-e5a7-4c0c-91be-2c06e2548cc0.png)
4. Внесите изменения в ваш форк, закоммитьте их. Для этого вам скорее всего потребуется склонировать ваш форк к себе на машину и поработать
в нем, но это не обязательное условие.
5. Создайте пулл-реквест из ветки `master` вашего проекта в ветку `master` моего проекта, убедитесь, что в нем есть все изменения, которые
вы внесли. Кстати, создать пулл-реквест можно прямо во время работы над заданием (до полного завершения), а новые коммиты автоматически в
него добавятся. Здесь я не могу предоставить вам скриншота, так как форка у меня нет.
6. Когда пулл-реквест будет готов к проверке - пишите в комментарии к пулл-реквесту или лично мне!

Вот [тут](https://git-scm.com/book/ru/v2/GitHub-%D0%92%D0%BD%D0%B5%D1%81%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81%D0%BE%D0%B1%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B2%D0%BA%D0%BB%D0%B0%D0%B4%D0%B0-%D0%B2-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D1%8B) подробнее про совместную работу над проектами, форки, пулл-реквесты и т.д.