# Техническое задание

_**Общие требования**_. Данное техническое задание формулирует следующие требования к вашему ПО:
1. Модуль, реализующий стек, должен быть выполнен как _статическая библиотека_. Это требование выполняется автоматически
([CMakeLists.txt](https://github.com/czertyaka/prosoft-c-stack/blob/master/CMakeLists.txt)) - весь код из `cstack.c` попадет в библиотеку.
2. Библиотека должна _собираться_, т.е. в ней не должно быть ошибок компиляции и линковки (за исключением ситуации отсутствия на машине
сборки стандартной библиотеки C).
3. Библиотека _не должна иметь зависимостей_ иных, чем стандартная библиотека C.
Не сомневаюсь, что при должном упорстве можно найти готовые реализации стека на С, удовлетворяющие нашим требованиям.
Это не наш случай :smiling_face_with_tear:.
5. Функции библиотеки должны удовлетворять требованиям, описанным ниже.
6. Библиотека должна корректно _освобождать ресурсы памяти_ при должном использовании.
7. Библиотека должна быть _отказоустойчива_ (в разумных пределах) _к входным данным_ функций, т.е. должны быть введены разумные проверки на нулевой указатель, нулевой размер и т.д. Понятно, что проверить валидность переданного указателя (например, что он не указывает в начало адресного пространства) невозможно или очень трудно, но полноценная проверка и не является ответственностью библиотеки.
8. В ходе нормального выполнения и использования кода библиотеки не должны возникать ошибки сегментации, переполнения стека, обращения к
памяти и др.
9. Библиотека не гарантирует: освобождение ресурсов памяти при некорректном использовании функций библиотеки; отсутствие недекларированного
поведения в случае передачи невалидного указателя (за исключением нулевого указателя).

Валидация этих требований будет осуществляется в процессе код-ревью, сборки и юнит-тестирования. Обратите внимание, что последние два
валидатора могут быть выполнены вами в целях экономии времени (в том числе и вашего). Но это лишь предложение по оптимизации процесса
проверки, а не требование. Обратите внимание, что юнит-тесты могут быть модифицированы в случае выявления недостаточности
проверок/несоответствия приведенным выше требованиям. Требования - первичны, а тесты всего лишь их выражают.

_**Особенности нашей реализации стека**_.
1. Библиотека может одновременно обслуживать несколько стеков.
2. Данные, хранимые в стеке, не типизированны.

**_Требования к функциям библиотеки_**.
Одним из аргументов большинства функций библиотеки является _хэндлер_ стека с типом `t_hstack`. Этот тип является псевдонимом типа `int`
и к реализации стека в памяти отношения не имеет. Скорее это абстрактный идентификатор, который нужен, чтобы отличить один стек от другого.
Отмечу, что в C использование _хэндлера_, (_дескриптора_), является стандартной практикой. Примеры:
[hInstance](https://learn.microsoft.com/ru-ru/windows/win32/learnwin32/winmain--the-application-entry-point) в `WinAPI`, возвращаемое
значение функции [open](https://man7.org/linux/man-pages/man2/open.2.html) в `POSIX`. Объявление этого типа находится в заголовочном файле
[cstack.h](https://github.com/czertyaka/prosoft-c-stack/blob/master/cstack.h).

* `hstack_t stack_new(void)`  
**Brief**: Создать новый стек.  
**Returns**: `-1` в случае ошибки выполнения, хэндлер нового стека с неотрицательным значением в случае успеха.

* `void stack_free(const hstack_t stack)`  
**Brief**: Удалить стек.  
**Parameters**: `stack` - хэндлер стека.

* `int stack_valid_handler(const hstack_t stack)`  
**Brief**: Проверить хэндлер.  
**Parameters**: `stack` - хэндлер стека.  
**Returns**: 0 - соответствующий хэндлеру стек существует, 1 - нет.

* `unsigned int stack_size(const hstack_t stack)`  
**Brief**: Получить количество элементов в стеке.  
**Parameters**: `stack` - хэндлер стека.  
**Returns**: количество элементов в стеке.

* `void stack_push(const hstack_t stack, const void* data_in, const unsigned int size)`  
**Brief**: Добавить элемент данных из буфера в стек.  
**Parameters**: `stack` - хэндлер стека; `data_in` - указатель на буфер с данными; `size` - размер буфера с данными.

* `unsigned int stack_pop(const hstack_t stack, void* data_out, const unsigned int size)`  
**Brief**: Извлечь элемент из стека и записать данные этого элемента в буфер.  
**Parameters**: `stack` - хэндлер стека; `data_out` - указатель на буфер для записи данных; `size` - размер буфера.  
**Returns**: размер записанных данных в байтах.

**_Подсказки по реализации_**. Прежде чем давать задание вам, я самостоятельно реализовал стек, чтобы было проще декомпозировать задачу и
подумать, в каких местах стоит дать подсказки. Эта часть необязательна к прочтению, ограничений на реализацию я не ставлю (кроме приведенных
в требованиях).

На мой взгляд, две главные проблемы, которые вам предстоит решить - как хранить сами данные в стеке и как устанавливать соответствие между
хэндлером и стеком.

Первая проблема решалась бы тривиально, если бы мы релизовывали стек, хранящий типизированные данные.
Тогда мы бы на этапе компиляции знали размер одного элемента стека.
Например, если бы мы хранили `int`, размер элемента стека в простой реализации был бы равен `sizeof(int)`.
В этом случае можно было бы вовсе обойтись без динамической памяти.
Пример можно найти [тут](http://shujkova.ru/sites/default/files/lec1.pdf).
Для случая неизвестного на этапе компиляции размера я выбрал вот такое решение:
```c
struct node
{
    const struct node* prev;
    unsigned int size;
    char data[0];
};
```
Такой подход напоминает другую структуру данных [односвязный список](https://prog-cpp.ru/data-ols/).
Из общего у них наличие указателя на предыдущий элемент.
При добавлении нового элемента в стек удобно в рантайме посчитать количество данных элемента стека
(размер указателя на предыдущий элемент `prev` + размер поля `size` + размер самих данных), аллоцировать
эти данные и заполнить их.
Это не единственно верный вариант, возможны альтернативы.

Вторую проблему я решил следующим образом: завел глобальный динамический массив указателей на верхушки стека так,
чтобы дескриптор стека являлся одновременно и индексом в этом массиве.
Добавил несколько оптимизаций, но общая идея такая.
```c
struct stack_entry
{
    int reserved;
    stack_t stack;
};

typedef struct stack_entry stack_entry_t;

struct stack_entries_table
{
    unsigned int size;
    stack_entry_t* entries;
};

struct stack_entries_table g_table = {0u, NULL};
```
**_Пошаговая инструкция_**

Вот [тут](https://git-scm.com/book/ru/v2/GitHub-%D0%92%D0%BD%D0%B5%D1%81%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81%D0%BE%D0%B1%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B2%D0%BA%D0%BB%D0%B0%D0%B4%D0%B0-%D0%B2-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D1%8B) подробнее про совместную работу над проектами, форки, пулл-реквесты и т.д.
